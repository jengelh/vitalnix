/*
 *	libvxutil/util.c - General functions
 *	Copyright Â© Jan Engelhardt <jengelh [at] medozas de>, 2003 - 2008
 *
 *	This file is part of Vitalnix. Vitalnix is free software; you
 *	can redistribute it and/or modify it under the terms of the GNU
 *	Lesser General Public License as published by the Free Software
 *	Foundation; either version 2.1 or 3 of the License.
 */
#include <sys/stat.h>
#include <sys/types.h>
#include <ctype.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <libHX/arbtree.h>
#include <libHX/defs.h>
#include <libHX/option.h>
#include <libHX/string.h>
#include <vitalnix/compiler.h>
#include <vitalnix/libvxutil/defines.h>
#include <vitalnix/libvxutil/libvxutil.h>
#define sizeof_z(s) (sizeof(s) - 1)

/* Functions */
static int vxutil_parse_date(const char *, unsigned int *, unsigned int *,
	unsigned int *);
static void vxutil_quote_base64(const char *, char *);
static size_t quoted_size(const char *, unsigned int);
static const char *surname_pointer(const char *);
static char *transform7(const char *, char *, size_t);

/* Variables */
static const char *const quote_match[] = {
	[VXQUOTE_SINGLE] = "'\\",
	[VXQUOTE_DOUBLE] = "\"\\",
	[VXQUOTE_XML]    = "\"&<>",
};

//-----------------------------------------------------------------------------
EXPORT_SYMBOL unsigned int vxutil_now_iday(void)
{
	return time(NULL) / 86400;
}

/**
 * vxutil_only_digits -
 * @p:	string to look at
 *
 * Returns whether the string in @p consists only of digits.
 */
EXPORT_SYMBOL bool vxutil_only_digits(const char *p)
{
	while (*p != '\0')
		if (!isdigit(*p++))
			return false;
	return true;
}

EXPORT_SYMBOL char *vxutil_propose_home(char *dest, size_t size,
    const char *base, const char *username, unsigned int level)
{
	if (*username == '\0')
		fprintf(stderr, "%s: username has zero length\n", __func__);
	if (level == 0)
		snprintf(dest, size, "%s/%s", base, username);
	else if (level == 1 || level == 10)
		snprintf(dest, size, "%s/%c/%s", base, *username, username);
	else if (level == 15)
		snprintf(dest, size, "%s/%c/%c/%s", base, username[0],
		         (username[1] == '\0') ? '_' : username[1], username);
	else
		snprintf(dest, size, "%s/%c/%c%c/%s", base, *username,
		         username[0], (username[1] == '\0') ? '_' : username[1],
		         username);

	return dest;
}

/**
 * vxutil_propose_lname -
 * @surname_8:		The surname (family name), UTF-8 encoded
 * @firstname_8:	The first name, UTF-8 encoded
 */
EXPORT_SYMBOL char *vxutil_propose_lname(char *dest, size_t size,
    const char *surname_8, const char *firstname_8)
{
	char surname_7[7], firstname_7[8];

	transform7(firstname_8, firstname_7, sizeof(firstname_7));

	if (surname_8 != NULL) {
		transform7(surname_pointer(surname_8), surname_7, sizeof(surname_7));
		snprintf(dest, size, "%c%s", *firstname_7, surname_7);
	} else {
		snprintf(dest, size, "%s", firstname_7);
	}

	if (strlen(dest) < 2 && size >= 3)
		/*
		 * In case the login name is too short, append a "0" (just
		 * cosmetics), it does not affect anything.
		 */
		strcat(dest, "0");

	return HX_strlower(dest);
}

EXPORT_SYMBOL char *vxutil_quote(const char *src, unsigned int type,
    char **free_me)
{
	char *ret, *ret_wp;

	if (type >= _VXQUOTE_MAX ||
	 (type <= VXQUOTE_XML && strpbrk(src, quote_match[type]) == NULL))
		return const_cast1(char *, src);

	/* Allocation and deallocation saving */
	ret = realloc(*free_me, quoted_size(src, type) + 1);
	if (ret == NULL)
		return NULL;
	*free_me = ret_wp = ret;

	if (type == VXQUOTE_BASE64) {
		vxutil_quote_base64(src, ret);
		return ret;
	}

	if (type == VXQUOTE_XML)
		while (*src != '\0') {
			size_t seg_len = strcspn(src, quote_match[type]);
			if (seg_len > 0) {
				memcpy(ret_wp, src, seg_len);
				ret_wp += seg_len;
				src    += seg_len;
				if (*src == '\0')
					break;
			}
			switch (*src++) {
				case '"':
					memcpy(ret_wp, "&quot;", 6);
					ret_wp += 6;
					break;
				case '&':
					memcpy(ret_wp, "&amp;", 5);
					ret_wp += 5;
					break;
				case '<':
					memcpy(ret_wp, "&lt;", 4);
					ret_wp += 4;
					break;
				case '>':
					memcpy(ret_wp, "&gt;", 4);
					ret_wp += 4;
					break;
			}
			*ret_wp = '\0';
			return ret;
		}

	while (*src != '\0') {
		size_t seg_len = strcspn(src, quote_match[type]);
		if (seg_len > 0) {
			memcpy(ret_wp, src, seg_len);
			ret_wp += seg_len;
			src    += seg_len;
			if (*src == '\0')
				break;
		}
		*ret_wp++ = '\\';
		*ret_wp++ = *src++;
	}

	*ret_wp = '\0';
	return ret;
}

EXPORT_SYMBOL int vxutil_replace_run(const char *fmt,
    const struct HXbtree *catalog)
{
	hxmc_t *cmd = NULL;
	int ret;
	HXformat_aprintf(catalog, &cmd, fmt);
	ret = system(cmd);
	HXmc_free(cmd);
	return ret;
}

EXPORT_SYMBOL char *vxutil_slurp_file(const char *fn)
{
	struct stat sb;
	char *dst;
	FILE *fp;

	if ((fp = fopen(fn, "rb")) == NULL)
		return NULL;
	if (fstat(fileno(fp), &sb) != 0)
		return NULL;
	if ((dst = calloc(1, sb.st_size + 1)) == NULL)
		return NULL;
	if (fread(dst, sb.st_size, 1, fp) < 1) {
		free(dst);
		return NULL;
	}

	fclose(fp);
	return dst;
}

EXPORT_SYMBOL int vxutil_string_iday(const char *s)
{
	unsigned int day = 0, month = 0, year = 0;
	struct tm td;
	int ret = 0;
	time_t sec;

	if ((ret = vxutil_parse_date(s, &day, &month, &year)) != 3)
		return ret;

	td.tm_mday = day;
	td.tm_mon  = month - 1;
	td.tm_year = year - 1900;
	if ((sec = mktime(&td)) == -1)
		return -1;

	return sec / 86400;
}

EXPORT_SYMBOL int vxutil_string_xday(const char *s)
{
	unsigned int day = 0, month = 0, year = 0;
	int ret = 0;
	if ((ret = vxutil_parse_date(s, &day, &month, &year)) <= 0)
		return ret;
	return ((year & 0xFFF) << 12) | ((month & 0xF) << 8) | (day & 0xFF);
}

EXPORT_SYMBOL bool vxutil_valid_username(const char *n)
{
	bool valid;

	if (*n == '\0')
		return false;
	if (!((*n >= 'A' && *n <= 'Z') || (*n >= 'a' && *n <= 'z') ||
	    *n == '_'))
		return false;

	while (*n != '\0') {
		if (*n == '$' && *(n+1) == '\0')
			/* Samba accounts */
			return true;

		valid = (*n >= 'A' && *n <= 'Z') || (*n >= 'a' && *n <= 'z') ||
		        (*n >= '0' && *n <= '9') || *n == '_' || *n == '.' ||
		        *n == '-';
		if (!valid)
			return false;
		++n;
	}

	return true;
}

//-----------------------------------------------------------------------------
static int vxutil_parse_date(const char *s, unsigned int *day,
    unsigned int *month, unsigned int *year)
{
	int ret = 0;

	if (strchr(s, '-') != NULL)
		/*
		 * ISO-8601 style YYYY-MM-DD,
		 * http://www.cl.cam.ac.uk/~mgk25/iso-time.html
		 * http://en.wikipedia.org/wiki/ISO-8601
		 */
		ret = sscanf(s, "%u-%u-%u", year, month, day);
	else if (strchr(s, '.') != NULL)
		/* European style DD.MM.YYYY */
		ret = sscanf(s, "%u.%u.%u", day, month, year);
	else if (strchr(s, '/') != NULL)
		/* American style MM/DD/YYYY */
		ret = sscanf(s, "%u/%u/%u", month, day, year);
	if (ret != 3)
		return -1;

	/*
	 * If any of the three are zero, the input date is illegal. If all
	 * three are zero, the equivalent meaning is "no date given".
	 */
	if (*day == 0 && *month == 0 && *year == 0)
		return 0;
	if (*day == 0 || *month == 0 || *year == 0)
		return -1;

	if (*year >= 100 && *year < 1000) {
		*year += 1900;
	} else if (*year < 100) {
		/*
		 * Fix two-digit year numbers. The range of two-digit years is
		 * always [now-50yrs ... now+50yrs].
		 */
		time_t now_sec = time(NULL);
		struct tm now_tm;
		int bp, nc;

		localtime_r(&now_sec, &now_tm);
		bp = (now_tm.tm_year + 50) % 100;
		nc = now_tm.tm_year - now_tm.tm_year % 100 +
		     ((bp < 50) ? 100 : 0);
		*year += 1900 + ((*year > bp) ? (nc - 100) : nc);
	}

	return 1;
}

/**
 * vxutil_quote_base64 -
 * @s:	string to encode
 * @d:	destination buffer
 *
 * Encode @src into BASE-64 according to RFC 4648 and write result to @dest,
 * which must be of appropriate size, plus one for a trailing NUL.
 */
static void vxutil_quote_base64(const char *s, char *d)
{
	static const char *a =
		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	size_t len = strlen(s);

	while (len > 0) {
		if (len >= 3) {
			len -= 3;
			d[0] = a[(s[0] & 0xFC) >> 2];
			d[1] = a[((s[0] & 0x03) << 4) | ((s[1] & 0xF0) >> 4)];
			d[2] = a[((s[1] & 0x0F) << 2) | ((s[2] & 0xC0) >> 6)];
			d[3] = a[s[2] & 0x3F];
		} else if (len == 2) {
			len = 0;
			d[0] = a[(s[0] & 0xFC) >> 2];
			d[1] = a[((s[0] & 0x03) << 4) | ((s[1] & 0xF0) >> 4)];
			d[2] = a[(s[1] & 0x0F) << 2];
			d[3] = '=';
		} else if (len == 1) {
			len = 0;
			d[0] = a[(s[0] & 0xFC) >> 2];
			d[1] = a[(s[0] & 0x03) << 4];
			d[2] = '=';
			d[3] = '=';
		}
		s += 3;
		d += 4;
	}
	*d = '\0';
}

/**
 * quoted_size -
 * @s:		string to analyze
 * @type:	non-zero if double quoted
 *
 * Returns the size of the string @s when quoted.
 */
static size_t quoted_size(const char *s, unsigned int type)
{
	const char *p = s;
	size_t n = strlen(s);

	/* The order of division and multiplication is _important_ here. */
	if (type == VXQUOTE_BASE64)
		return (strlen(s) + 2) / 3 * 4;

	if (type == VXQUOTE_XML) {
		while ((p = strpbrk(p, quote_match[type])) != NULL) {
			switch (*p) {
				/* minus 2: \0 and the original char */
				case '"':
					n += sizeof("&quot;") - 2;
					break;
				case '&':
					n += sizeof("&amp;") - 2;
					break;
				case '<':
				case '>':
					n += sizeof("&lt;") - 2;
					break;
			}
			++p;
		}
		return n;
	}

	while ((p = strpbrk(p, quote_match[type])) != NULL) {
		++n;
		++p;
	}

	return n;
}

/**
 * surname_pointer -
 * @s:	string to analyze
 *
 * Return a pointer to the first word that begins with an uppercase character.
 * If there is none that matches this criteria, return a pointer to the second
 * word, if there is any. If that also does not exist, return the original
 * pointer (i.e. to the first word).
 *
 * Note that this only works for standard ASCII A-Z, and not umlauts, etc.
 *
 * Examples:
 *     van der Waals   => Waals
 *     van der waals   => der waals
 *     waals           => waals
 */
static const char *surname_pointer(const char *s)
{
	const char *p;

	while (isspace(*s))
		++s;
	p = s;

	while (*p != '\0') {
		if (isupper(*p))
			return p;
		while (!isspace(*p) && *p != '\0')
			++p;
		while (isspace(*p))
			++p;
	}
	if ((p = strchr(s, ' ')) != NULL) {
		while (isspace(*p))
			++p;
		return p;
	}
	return s;
}

static const struct stab {
	const char *in, *out;
	int is, os;
} subst_tab[] = {
#define E(s, d) {(s), (d), sizeof(s) - 1, sizeof(d) - 1}
	/* [U+00B5] */ E("Âµ", "m"),
	/* [U+00C0] */ E("Ã", "A"),
	/* [U+00C1] */ E("Ã", "A"),
	/* [U+00C2] */ E("Ã", "A"),
	/* [U+00C3] */ E("Ã", "A"),
	/* [U+00C4] */ E("Ã", "AE"),
	/* [U+00C5] */ E("Ã", "A"),
	/* [U+00C6] */ E("Ã", "AE"),
	/* [U+00C7] */ E("Ã", "C"),
	/* [U+00C8] */ E("Ã", "E"),
	/* [U+00C9] */ E("Ã", "E"),
	/* [U+00CA] */ E("Ã", "E"),
	/* [U+00CB] */ E("Ã", "E"),
	/* [U+00CC] */ E("Ã", "I"),
	/* [U+00CD] */ E("Ã", "I"),
	/* [U+00CE] */ E("Ã", "I"),
	/* [U+00CF] */ E("Ã", "I"),
	/* [U+00D0] */ E("Ã", "TH"),
	/* [U+00D1] */ E("Ã", "N"),
	/* [U+00D2] */ E("Ã", "O"),
	/* [U+00D3] */ E("Ã", "O"),
	/* [U+00D4] */ E("Ã", "O"),
	/* [U+00D5] */ E("Ã", "O"),
	/* [U+00D6] */ E("Ã", "OE"),
	/* [U+00D8] */ E("Ã", "O"),
	/* [U+00D9] */ E("Ã", "U"),
	/* [U+00DA] */ E("Ã", "U"),
	/* [U+00DB] */ E("Ã", "U"),
	/* [U+00DC] */ E("Ã", "UE"),
	/* [U+00DD] */ E("Ã", "Y"),
	/* [U+00DE] */ E("Ã", "TH"),
	/* [U+00DF] */ E("Ã", "ss"),
	/* [U+00E0] */ E("Ã ", "a"),
	/* [U+00E1] */ E("Ã¡", "a"),
	/* [U+00E2] */ E("Ã¢", "a"),
	/* [U+00E3] */ E("Ã£", "a"),
	/* [U+00E4] */ E("Ã¤", "ae"),
	/* [U+00E5] */ E("Ã¥", "a"),
	/* [U+00E6] */ E("Ã¦", "ae"),
	/* [U+00E7] */ E("Ã§", "c"),
	/* [U+00E8] */ E("Ã¨", "e"),
	/* [U+00E9] */ E("Ã©", "e"),
	/* [U+00EA] */ E("Ãª", "e"),
	/* [U+00EB] */ E("Ã«", "e"),
	/* [U+00EC] */ E("Ã¬", "i"),
	/* [U+00ED] */ E("Ã­", "i"),
	/* [U+00EE] */ E("Ã®", "i"),
	/* [U+00EF] */ E("Ã¯", "i"),
	/* [U+00F0] */ E("Ã°", "th"),
	/* [U+00F1] */ E("Ã±", "n"),
	/* [U+00F2] */ E("Ã²", "o"),
	/* [U+00F3] */ E("Ã³", "o"),
	/* [U+00F4] */ E("Ã´", "o"),
	/* [U+00F5] */ E("Ãµ", "o"),
	/* [U+00F6] */ E("Ã¶", "oe"),
	/* [U+00F8] */ E("Ã¸", "o"),
	/* [U+00F9] */ E("Ã¹", "u"),
	/* [U+00FA] */ E("Ãº", "u"),
	/* [U+00FB] */ E("Ã»", "u"),
	/* [U+00FC] */ E("Ã¼", "ue"),
	/* [U+00FD] */ E("Ã½", "y"),
	/* [U+00FE] */ E("Ã¾", "th"),
	/* [U+00FF] */ E("Ã¿", "y"),
	/* [U+0100] */ E("Ä", "A"),
	/* [U+0101] */ E("Ä", "a"),
	/* [U+0102] */ E("Ä", "A"),
	/* [U+0103] */ E("Ä", "a"),
	/* [U+0104] */ E("Ä", "A"),
	/* [U+0105] */ E("Ä", "a"),
	/* [U+0106] */ E("Ä", "C"),
	/* [U+0107] */ E("Ä", "c"),
	/* [U+0108] */ E("Ä", "C"),
	/* [U+0109] */ E("Ä", "c"),
	/* [U+010A] */ E("Ä", "C"),
	/* [U+010B] */ E("Ä", "c"),
	/* [U+010C] */ E("Ä", "C"),
	/* [U+010D] */ E("Ä", "c"),
	/* [U+010E] */ E("Ä", "D"),
	/* [U+010F] */ E("Ä", "d"),
	/* [U+0110] */ E("Ä", "D"),
	/* [U+0111] */ E("Ä", "d"),
	/* [U+0112] */ E("Ä", "E"),
	/* [U+0113] */ E("Ä", "e"),
	/* [U+0114] */ E("Ä", "E"),
	/* [U+0115] */ E("Ä", "e"),
	/* [U+0116] */ E("Ä", "E"),
	/* [U+0117] */ E("Ä", "e"),
	/* [U+0118] */ E("Ä", "E"),
	/* [U+0119] */ E("Ä", "e"),
	/* [U+011A] */ E("Ä", "E"),
	/* [U+011B] */ E("Ä", "e"),
	/* [U+011C] */ E("Ä", "G"),
	/* [U+011D] */ E("Ä", "g"),
	/* [U+011E] */ E("Ä", "G"),
	/* [U+011F] */ E("Ä", "g"),
	/* [U+0120] */ E("Ä ", "G"),
	/* [U+0121] */ E("Ä¡", "g"),
	/* [U+0122] */ E("Ä¢", "G"),
	/* [U+0123] */ E("Ä£", "g"),
	/* [U+0124] */ E("Ä¤", "H"),
	/* [U+0125] */ E("Ä¥", "h"),
	/* [U+0126] */ E("Ä¦", "H"),
	/* [U+0127] */ E("Ä§", "h"),
	/* [U+0128] */ E("Ä¨", "I"),
	/* [U+0129] */ E("Ä©", "i"),
	/* [U+012A] */ E("Äª", "I"),
	/* [U+012B] */ E("Ä«", "i"),
	/* [U+012C] */ E("Ä¬", "I"),
	/* [U+012D] */ E("Ä­", "i"),
	/* [U+012E] */ E("Ä®", "I"),
	/* [U+012F] */ E("Ä¯", "i"),
	/* [U+0130] */ E("Ä°", "I"),
	/* [U+0131] */ E("Ä±", "i"),
	/* [U+0132] */ E("Ä²", "IJ"),
	/* [U+0133] */ E("Ä³", "ij"),
	/* [U+0134] */ E("Ä´", "J"),
	/* [U+0135] */ E("Äµ", "j"),
	/* [U+0136] */ E("Ä¶", "K"),
	/* [U+0137] */ E("Ä·", "k"),
	/* [U+0138] */ E("Ä¸", "k"),
	/* [U+0139] */ E("Ä¹", "L"),
	/* [U+013A] */ E("Äº", "l"),
	/* [U+013B] */ E("Ä»", "L"),
	/* [U+013C] */ E("Ä¼", "l"),
	/* [U+013D] */ E("Ä½", "L"),
	/* [U+013E] */ E("Ä¾", "l"),
	/* [U+013F] */ E("Ä¿", "L"),
	/* [U+0140] */ E("Å", "l"),
	/* [U+0141] */ E("Å", "L"),
	/* [U+0142] */ E("Å", "l"),
	/* [U+0143] */ E("Å", "N"),
	/* [U+0144] */ E("Å", "n"),
	/* [U+0145] */ E("Å", "N"),
	/* [U+0146] */ E("Å", "n"),
	/* [U+0147] */ E("Å", "N"),
	/* [U+0148] */ E("Å", "n"),
	/* [U+0149] */ E("Å", "n"),
	/* [U+014A] */ E("Å", "NG"),
	/* [U+014B] */ E("Å", "ng"),
	/* [U+014C] */ E("Å", "O"),
	/* [U+014D] */ E("Å", "o"),
	/* [U+014E] */ E("Å", "O"),
	/* [U+014F] */ E("Å", "o"),
	/* [U+0150] */ E("Å", "O"),
	/* [U+0151] */ E("Å", "o"),
	/* [U+0152] */ E("Å", "OE"),
	/* [U+0153] */ E("Å", "oe"),
	/* [U+0154] */ E("Å", "R"),
	/* [U+0155] */ E("Å", "r"),
	/* [U+0156] */ E("Å", "R"),
	/* [U+0157] */ E("Å", "r"),
	/* [U+0158] */ E("Å", "R"),
	/* [U+0159] */ E("Å", "r"),
	/* [U+015A] */ E("Å", "S"),
	/* [U+015B] */ E("Å", "s"),
	/* [U+015C] */ E("Å", "S"),
	/* [U+015D] */ E("Å", "s"),
	/* [U+015E] */ E("Å", "S"),
	/* [U+015F] */ E("Å", "s"),
	/* [U+0160] */ E("Å ", "S"),
	/* [U+0161] */ E("Å¡", "s"),
	/* [U+0162] */ E("Å¢", "T"),
	/* [U+0163] */ E("Å£", "t"),
	/* [U+0164] */ E("Å¤", "T"),
	/* [U+0165] */ E("Å¥", "t"),
	/* [U+0166] */ E("Å¦", "T"),
	/* [U+0167] */ E("Å§", "t"),
	/* [U+0168] */ E("Å¨", "U"),
	/* [U+0169] */ E("Å©", "u"),
	/* [U+016A] */ E("Åª", "U"),
	/* [U+016B] */ E("Å«", "u"),
	/* [U+016C] */ E("Å¬", "U"),
	/* [U+016D] */ E("Å­", "u"),
	/* [U+016E] */ E("Å®", "U"),
	/* [U+016F] */ E("Å¯", "u"),
	/* [U+0170] */ E("Å°", "U"),
	/* [U+0171] */ E("Å±", "u"),
	/* [U+0172] */ E("Å²", "U"),
	/* [U+0173] */ E("Å³", "u"),
	/* [U+0174] */ E("Å´", "W"),
	/* [U+0175] */ E("Åµ", "w"),
	/* [U+0176] */ E("Å¶", "Y"),
	/* [U+0177] */ E("Å·", "y"),
	/* [U+0178] */ E("Å¸", "Y"),
	/* [U+0179] */ E("Å¹", "Z"),
	/* [U+017A] */ E("Åº", "z"),
	/* [U+017B] */ E("Å»", "Z"),
	/* [U+017C] */ E("Å¼", "z"),
	/* [U+017D] */ E("Å½", "Z"),
	/* [U+017E] */ E("Å¾", "z"),
	/* [U+017F] */ E("Å¿", "s"),
	/* [U+0180] */ E("Æ", "b"),
	/* [U+0181] */ E("Æ", "B"),
	/* [U+0182] */ E("Æ", "B"),
	/* [U+0183] */ E("Æ", "b"),
	/* [U+0184] */ E("Æ", "b"),
	/* [U+0185] */ E("Æ", "b"),
	/* [U+0186] */ E("Æ", "C"),
	/* [U+0187] */ E("Æ", "C"),
	/* [U+0188] */ E("Æ", "c"),
	/* [U+0189] */ E("Æ", "TH"),
	/* [U+018A] */ E("Æ", "D"),
	/* [U+018B] */ E("Æ", "D"),
	/* [U+018C] */ E("Æ", "d"),
	/* [U+018D] */ E("Æ", "d"),
	/* [U+018E] */ E("Æ", "E"),
	/* [U+0190] */ E("Æ", "E"),
	/* [U+0191] */ E("Æ", "F"),
	/* [U+0192] */ E("Æ", "f"),
	/* [U+0193] */ E("Æ", "G"),
	/* [U+0194] */ E("Æ", "G"),
	/* [U+0195] */ E("Æ", "hv"),
	/* [U+0196] */ E("Æ", "I"),
	/* [U+0197] */ E("Æ", "I"),
	/* [U+0198] */ E("Æ", "K"),
	/* [U+0199] */ E("Æ", "k"),
	/* [U+019A] */ E("Æ", "l"),
	/* [U+019B] */ E("Æ", "l"),
	/* [U+019C] */ E("Æ", "m"),
	/* [U+019D] */ E("Æ", "N"),
	/* [U+019E] */ E("Æ", "n"),
	/* [U+019F] */ E("Æ", "O"),
	/* [U+01A0] */ E("Æ ", "O"),
	/* [U+01A1] */ E("Æ¡", "o"),
	/* [U+01A2] */ E("Æ¢", "GHA"),
	/* [U+01A3] */ E("Æ£", "gha"),
	/* [U+01A4] */ E("Æ¤", "P"),
	/* [U+01A5] */ E("Æ¥", "p"),
	/* [U+01A6] */ E("Æ¦", "yr"),
	/* [U+01A7] */ E("Æ§", "S"),
	/* [U+01A8] */ E("Æ¨", "s"),
	/* [U+01A9] */ E("Æ©", "ESH"),
	/* [U+01AC] */ E("Æ¬", "T"),
	/* [U+01AD] */ E("Æ­", "t"),
	/* [U+01AE] */ E("Æ®", "T"),
	/* [U+01AF] */ E("Æ¯", "U"),
	/* [U+01B0] */ E("Æ°", "u"),
	/* [U+01B1] */ E("Æ±", "U"),
	/* [U+01B2] */ E("Æ²", "V"),
	/* [U+01B3] */ E("Æ³", "Y"),
	/* [U+01B4] */ E("Æ´", "y"),
	/* [U+01B5] */ E("Æµ", "Z"),
	/* [U+01B6] */ E("Æ¶", "z"),
	/* [U+01B7] */ E("Æ·", "EZH"),
	/* [U+01B8] */ E("Æ¸", "EZH"),
	/* [U+01B9] */ E("Æ¹", "ezh"),
	/* [U+01BA] */ E("Æº", "ezh"),
	/* [U+01C4] */ E("Ç", "DZ"),
	/* [U+01C5] */ E("Ç", "Dz"),
	/* [U+01C6] */ E("Ç", "dz"),
	/* [U+01C7] */ E("Ç", "LJ"),
	/* [U+01C8] */ E("Ç", "Lj"),
	/* [U+01C9] */ E("Ç", "lj"),
	/* [U+01CA] */ E("Ç", "NJ"),
	/* [U+01CB] */ E("Ç", "Nj"),
	/* [U+01CC] */ E("Ç", "nj"),
	/* [U+01CD] */ E("Ç", "A"),
	/* [U+01CE] */ E("Ç", "a"),
	/* [U+01CF] */ E("Ç", "I"),
	/* [U+01D0] */ E("Ç", "i"),
	/* [U+01D1] */ E("Ç", "O"),
	/* [U+01D2] */ E("Ç", "o"),
	/* [U+01D3] */ E("Ç", "U"),
	/* [U+01D4] */ E("Ç", "u"),
	/* [U+01D5] */ E("Ç", "U"),
	/* [U+01D6] */ E("Ç", "u"),
	/* [U+01D7] */ E("Ç", "U"),
	/* [U+01D8] */ E("Ç", "u"),
	/* [U+01D9] */ E("Ç", "U"),
	/* [U+01DA] */ E("Ç", "u"),
	/* [U+01DB] */ E("Ç", "U"),
	/* [U+01DC] */ E("Ç", "u"),
	/* [U+01DD] */ E("Ç", "e"),
	/* [U+01DE] */ E("Ç", "A"),
	/* [U+01DF] */ E("Ç", "a"),
	/* [U+01E0] */ E("Ç ", "A"),
	/* [U+01E1] */ E("Ç¡", "a"),
	/* [U+01E2] */ E("Ç¢", "AE"),
	/* [U+01E3] */ E("Ç£", "ae"),
	/* [U+01E4] */ E("Ç¤", "G"),
	/* [U+01E5] */ E("Ç¥", "g"),
	/* [U+01E6] */ E("Ç¦", "G"),
	/* [U+01E7] */ E("Ç§", "g"),
	/* [U+01E8] */ E("Ç¨", "K"),
	/* [U+01E9] */ E("Ç©", "k"),
	/* [U+01EA] */ E("Çª", "O"),
	/* [U+01EB] */ E("Ç«", "o"),
	/* [U+01EC] */ E("Ç¬", "O"),
	/* [U+01ED] */ E("Ç­", "o"),
	/* [U+01EE] */ E("Ç®", "EZH"),
	/* [U+01EF] */ E("Ç¯", "ezh"),
	/* [U+01F0] */ E("Ç°", "j"),
	/* [U+01F1] */ E("Ç±", "DZ"),
	/* [U+01F2] */ E("Ç²", "Dz"),
	/* [U+01F3] */ E("Ç³", "dz"),
	/* [U+01F4] */ E("Ç´", "G"),
	/* [U+01F5] */ E("Çµ", "g"),
	/* [U+01F6] */ E("Ç¶", "Hv"),
	/* [U+01F8] */ E("Ç¸", "N"),
	/* [U+01F9] */ E("Ç¹", "n"),
	/* [U+01FA] */ E("Çº", "A"),
	/* [U+01FB] */ E("Ç»", "a"),
	/* [U+01FC] */ E("Ç¼", "AE"),
	/* [U+01FD] */ E("Ç½", "ae"),
	/* [U+01FE] */ E("Ç¾", "O"),
	/* [U+01FF] */ E("Ç¿", "o"),
	/* [U+0200] */ E("È", "A"),
	/* [U+0201] */ E("È", "a"),
	/* [U+0202] */ E("È", "A"),
	/* [U+0203] */ E("È", "a"),
	/* [U+0204] */ E("È", "E"),
	/* [U+0205] */ E("È", "e"),
	/* [U+0206] */ E("È", "E"),
	/* [U+0207] */ E("È", "e"),
	/* [U+0208] */ E("È", "I"),
	/* [U+0209] */ E("È", "i"),
	/* [U+020A] */ E("È", "I"),
	/* [U+020B] */ E("È", "i"),
	/* [U+020C] */ E("È", "O"),
	/* [U+020D] */ E("È", "o"),
	/* [U+020E] */ E("È", "O"),
	/* [U+020F] */ E("È", "o"),
	/* [U+0210] */ E("È", "R"),
	/* [U+0211] */ E("È", "r"),
	/* [U+0212] */ E("È", "R"),
	/* [U+0213] */ E("È", "r"),
	/* [U+0214] */ E("È", "U"),
	/* [U+0215] */ E("È", "u"),
	/* [U+0216] */ E("È", "U"),
	/* [U+0217] */ E("È", "u"),
	/* [U+0218] */ E("È", "S"),
	/* [U+0219] */ E("È", "s"),
	/* [U+021A] */ E("È", "T"),
	/* [U+021B] */ E("È", "t"),
	/* [U+021E] */ E("È", "EZH"),
	/* [U+021F] */ E("È", "ezh"),
	/* [U+0220] */ E("È ", "H"),
	/* [U+0222] */ E("È¢", "N"),
	/* [U+0223] */ E("È£", "d"),
	/* [U+0226] */ E("È¦", "Z"),
	/* [U+0227] */ E("È§", "z"),
	/* [U+0228] */ E("È¨", "A"),
	/* [U+0229] */ E("È©", "a"),
	/* [U+022A] */ E("Èª", "E"),
	/* [U+022B] */ E("È«", "e"),
	/* [U+022A] */ E("Èª", "O"),
	/* [U+022B] */ E("È«", "o"),
	/* [U+022C] */ E("È¬", "O"),
	/* [U+022D] */ E("È­", "o"),
	/* [U+022E] */ E("È®", "O"),
	/* [U+022F] */ E("È¯", "o"),
	/* [U+0230] */ E("È°", "O"),
	/* [U+0231] */ E("È±", "o"),
	/* [U+0232] */ E("È²", "Y"),
	/* [U+0233] */ E("È³", "y"),
	{NULL},
#undef E
};

/**
 * transform7 -
 * @src:	Source string to transform
 * @dest:	Destination buffer
 * @dsize:	Size of destination buffer
 *
 * Transform an UTF-8 string @src into a 7-bit clean string according to the
 * substitution table and put the result into @dest, which is of size @dsize.
 * (So it puts in at most @dsize-1 characters.) The result will always be
 * '\0'-terminated.
 */
char *transform7(const char *src, char *dest, size_t dsize)
{
	char *od = dest;
	--dsize;
	while (dsize && *src != '\0') {
		/*
		 * Yes, no digit handling. This function is mainly used as part
		 * to produce login names, which better should not have
		 * numbers. (Since we may potentially be adding one, anyhow.)
		 */
		if ((*src >= 'A' && *src <= 'Z') || (*src >= 'a' && *src <= 'z')) {
			*dest++ = *src++;
			--dsize;
		} else if (*signed_cast(const unsigned char *, src) & 0x80) {
			const struct stab *sp = subst_tab;
			int ok = 0;
			for (sp = subst_tab; sp->in != NULL; ++sp) {
				if (strncmp(src, sp->in, sp->is) != 0)
					continue;
				ok   = 1;
				src += sp->is;
				if (dsize >= sp->os) {
					strncpy(dest, sp->out, sp->os);
					dest  += sp->os;
					dsize -= sp->os;
				} else {
					/*
					 * Do not let "abcdeÃ¶a" through,
					 * because if there was	too few space,
					 * the "Ã¶" gets skipped but @dsize is
					 * still big enough to let the "a" in.
					 */
					dsize = 0;
				}
				break;
			}
			/* Just skip things we can not transform */
			if (!ok)
				++src;
		} else {
			++src;
		}
	}
	*dest = '\0';
	return od;
}
