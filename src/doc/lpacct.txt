
Administrator's Book >>> Vitalnix Print Accounting


1. Intro
========


2. Installation
===============

2.1. CUPS
=========

Unlike other print accounting solutions, the Vitalnix lpacct hook is
implemented as a CUPS filter rather than as a CUPS backend. Because CUPS lacks
the feature to dynamically define filters (such as in a text file) as of this
writing, a patch to the CUPS source is necessary, and this will most likely
continue even after pre-filters are supported in CUPS. However, all of this has
a number of advantages over backend-based accounting solutions:

1. Backend accounting receives printer-specific language data. Data needs to
translated back into a simple raster format, or is at least is interpreted
right away, i.e. directly count ink coverage. Either way, you need a decoder
for this. In the worst case, there is no decoder written yet, and in the other
case, the decoder must be kept updated/in sync with the encoder.

2. Most likely you will get an intermediate Postscript file in the filtering
process as a result of mime conversions towards printer language. For example,
if you print an image from the command line using `lpr foo.png`, the filter
chain will be image/png -> application/vnd.cups-postscript -> printer/*. Since
Vitalnix lpacct operates on Postscript, the lpacct filter can just be inserted
after the PNG-to-PS conversion has been done.

(It is probably not as fast as backend counting, but a lot less complex.)

So you have to get CUPS's source tarball, extract, patch and compile it.
It is advised to use the distributions packaging methods, e.g. src.rpm for
openSUSE/SLE* or Fedora/Redhat, to keep installation and upgrade relatively
easy. Precompiled CUPS packages for openSUSE can be found in

  http://jengelh.hopto.org/ftp/


2.2. Syslog
===========
In its simplest form, lpacct will make a syslog entry for each print job.
You can then grep them from /var/log/messages and process them any way you
like. Beware of automatic system log rotation utilities.


2.3. MYSQL
==========
- set up mysql db


3. Usage
========

3.1. Mode of operation
======================

vxlpacct, in its current form, is a non-enforcing system, which means
it does not stop a job from actually being printed. With respect to
this, vxlpacct was designed as being a post pay system. The common
cases as supported by Steelmill are explained in ch4.

3.1.1. Per pvgrp processing
===========================


Steelmill/lpcadm ways

Selection

 -  list jobs of user
    select * from printlog where user='XYZ';

 -  list jobs of group

 -  list users of group

 -  list jobs of pvgrp
    select count(*),sum(total),sum(pages) from printlog
    where pvgrp='XYZ' group by pvgrp;

 -  list users of pvgrp
    select count(*),user,sum(total),sum(pages) from printlog
    where pvgrp='XYZ' group by user;

Operation

 -  delete selected entries

 -  delete all entries in view

 -  truncate complete print log


3.1.2. Per-user processing
==========================



3.2. Cost preview
=================

Because accounting and analyzing is about the same job, the lpacct program has
a limited command-line debug interface with which the cost of a print job can
be analyzed before it is actually sent to the printer.

Since the filter program is usually called by CUPS, only Postscript is
supported. An extra flag allows for PPM/PGMs to be passed, but that is really
only for debugging and optimizing and tuning the analyzer algorithms.

Note that the default analysis precision (dots per inch) is hard-coded
and I do not know of a way to dynamically change it on a per-job basis
from within CUPS. With the CLI, the -d option may be used, but the
results may differ slightly between different DPI values. 300 DPI is the
current hardcoded default and is a good compromise between precision and
speed, slightly biased towards precision.


3.3. Accounting summary
=======================

`lpaview` is a CGI binary that allows a user to see what prints job were
sent to the queue and what their cost in the unit "i*A4" (intensity x ISO A4)
is. Total page count is also displayed. Detailed stats about exact CMYK
ink usage can be selected at the login dialog.


3.4. Totals overview
====================


3.5. Cleaning database
======================

As each user prints a document, details about it will be logged into a mysql
table. The table will grow until it is manually flushed by the administrator,
usually when the accounting period is over and it is time for cashing up. The
exact details on how the collected data is used or billed is up to the
administrator or authoritative people, respectively, which is why there are no
tools besides the simple `lpaview`.

The simplest approach to empty the table and hence reset the counters it to
do it with the following mysql statement:

  truncate vxlpacct.printlog;



Internals book >>> Vitalnix print accounting


1. Internal workings
====================

1.1. CMYK analyzer
==================
The CMYK analyzer is (rightfully) slower than the CMY one. The reason
is simple: calculating the black component, and doing undercolor
removal on the original CMY values.


1.2. CMY+K analyzer
===================
You may find a small oddity in the pxcost_cmypk() function:

    if(kdist(r, g, b) <= 8)
        tk += mean3(r, g, b);

This heuristic decides whether a pixel should be printed using CMY or
K. (Note that CMY+K means only one of the two groups can be printed
at the same time due to chemical instabilities.) kdist() calculates
the distance of a point towards the gray baseline (the set of points
where r=g=b) in the RGB cube. The maximum distance 8 is an arbitrary
value chosen by the author and roughly corresponds to a maximum
single pixel value deviation of 2*Sqrt[3].


2. Optimizing counting
======================

2.1. Gray counting on a 24-bit truecolor image
==============================================
The standard counting algorithm is

    while(pixels-- > 0)
        k += 255 - rgb_to_gray(r, g, b);

expanded, this is

    k += 255 - (76 * red + 151 * green + 27 * blue) / 256

You can see that there is the "255 - " part which is the same for all
iterations. It can be optimized away by adding up 255 for all pixels
at once and then decrement k:

    k = 255 * pixels;
    while(pixels-- > 0)
        k -= (76 * red + 151 * green + 27 * blue) / 256;



2.2. Gray counting on an 8-bit grayscale image
==============================================
The input is an array of "white" pixels, where black is represented
by 0 and white by 255. So to count the black ink coverage K, one
would write

    while(pixels-- > 0)
        k += 255 - *current++;

However, we can save the W->K conversion that is done _for every
pixel_ by inverting the image beforehand, as in

    invert_image(image);
    while(pixels-- > 0)
        k += *current++;

Both approaches can be combined: not having to invert the image but
also no extra operation inside the loop. Assuming the image was
totally black, subtract W pixels:

    k += 255 * pixels;
    while(pixels-- > 0)
        k -= *current++;
