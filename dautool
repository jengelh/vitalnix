#!/usr/bin/perl
#==============================================================================
# DAUtool - Massenbenutzerverwaltung
#   Copyright (C) Jan Engelhardt <jengelh at gmx de>, 1999 - 2003
#   -- distributed under the GPL >= v2.0 --
#
#   Other contributors:
#   Chistoph Thiel <cthiel1@linux01.gwdg.de>, 2001 - 2003
#   <acb@kki.org>, 2002
#==============================================================================
BEGIN { push(@INC, "src"); }

%OPT = (
  "PROGF" => "dautool",
  "PROGN" => "dautool",
  "PROGV" => "v1.73.8",
  "PROGD" => "29. August 2003",
  "a_cfgf" => ["dautool.cfg"],
  "b_saupw" => 0,
  "b_zpack" => 2,
  "f_group" => "/etc/group",
  "f_passwd" => "/etc/passwd",
  "f_shadow" => "/etc/shadow",
  "f_skeldir" => "/tmp/dautool.skel",
  "f_trhome" => "/home/_trash",
  "s_passlen" => 8,
  "s_dgrp" => "change_this", # changes in conf file
  "p_pager" => (-e $ENV{"PAGER"}) ? $ENV{"PAGER"} :
    (-e "/usr/bin/less") ? "/usr/bin/less" :
    (-e "/usr/bin/w3m") ? "/usr/bin/w3m" :
    (-e "/bin/more") ? "/bin/more" : "/bin/true",
  "p_useradd" => "/usr/sbin/useradd",
  "pa_useradd" => "\"%1\$s\" -c \"%5\$s\" -g \"%4\$s\" -mk \"%7\$s\" -p \"%3\$s\" -s \"%6\$s\" \"%2\$s\"",
  "p_userdel" => "/usr/sbin/userdel",
  "pa_userdel" => "\"%1\$s\" -r \"%2\$s\"",
  "p_preadd" => "",
  "pa_preadd" => "\"%1\$s\" -c \"%5\$s\" -g \"%4\$s\" -mk \"%7\$s\" -p \"%3\$s\" -s \"%6\$s\" \"%2\$s\"",
  "p_predel" => "",
  "pa_predel" => "\"%1\$s\"",
  "p_postadd" => "",
  "pa_postadd" => "\"%1\$s\"",
  "p_postdel" => "",
  "pa_postdel" => "\"%1\$s\"",
);

%CURR = (
  "a_udel" => [],
  "a_ukeep" => [],
  "a_unew" => [],
  "b_cmpd" => 0,
  "r_gid" => ".*?",
  "r_homedir" => ".*?",
  "r_klasse" => ".*?",
  "r_lname" => ".*?",
  "r_rname" => ".*?",
  "r_shell" => ".*?",
  "r_uid" => ".*?",
);

@OPT{"s_termwy","s_termwx"} = (`stty size 2>/dev/null` =~ /^(\d+)\s+(\d+)/);
$OPT{"s_termwx"} ||= 80; $OPT{"s_termwy"} ||= 25;

# ----------------------------------------
print "\e[1m", $OPT{"PROGN"}, " ", $OPT{"PROGV"}, "\e[0m\n";
print "by Jan Engelhardt <jengelh at gmx de>, 1999 - 2003\n";
print "=" x 40, "\n";
select((select(STDOUT), $| = 1)[0]);
select((select(STDERR), $| = 1)[0]);

use Getopt::Long;
require "a2a.pm";
require "datescram.pm";

*enday = \&date_scramble;
*to_ansi = \&Convert::A2A::to_ansi;

# ----------------------------------------
&Getopt::Long::Configure(qw(bundling pass_through));
&GetOptions("c=s" => $OPT{"a_cfgf"});

foreach my $f (@{$OPT{"a_cfgf"}}) {
 if(do $f) { printf "Lade Konfiguration aus Datei %s\n", $f; } }

# ----------------------------------------
@SIG{"HUP","INT","TERM"} = ((\&SIG_EXIT) x 3);

&hmenu();
sub SIG_EXIT { unlink "/var/run/".$OPT{"PROGF"}.".pid"; print "\n"; exit 1; }
END { unlink "/var/run/".$OPT{"PROGF"}.".pid"; print "\n"; }

sub hmenu {
  while() {
    print "\n", &hbar("="), "\n\e[1mHauptmenü\e[0m\n", &hbar("="), "\n";
    print "< 1 >  Assistent\n";
    print "< 2 >  Änderungen finden\n";
    print "< 3 >  Änderungen zuweisen\n";
    print "< 4 >  Passwortliste drucken\n";
    print "-" x 40, "\n";
    print "< 5 >  Einzelnen Benutzer hinzufügen\n";
    print "< 6 >  Benutzerdetails\n";
    print "-" x 40, "\n";
    print "< 0 >  Beenden\n\n";
    print "WAHL>  ";

    chomp(my $INKEY = <STDIN>);
    if($INKEY eq "1") { &assistant(); }
    elsif($INKEY eq "2") { &find_changes(); }
    elsif($INKEY eq "3") { &apply_changes(); }
    elsif($INKEY eq "4") { &prlist(); }
    elsif($INKEY eq "5") { &useradd(); }
    elsif($INKEY eq "6") { &userdetails(); }
    elsif($INKEY =~ /^[0q]$/io) { last; }
    print "\n\n\n";
  }
}

sub assistant {
  my $temp;
  print "\n\n\n", &hbar("="), "\n\e[1mAssistent\e[0m\n", &hbar("="), "\n";
  print &tssqueeze("Wird das Programm zwischendurch unter-/abgebrochen,".
   "so erkennt es bei erneuter Ausführung bereits erledigte Aufgaben."), "\n";
  print &tssqueeze("In [] befinden sich alle wählbaren Möglichkeiten, ".
   "diejenige die in ()-Klammern ist, wird angenommen wenn die Eingabe leer ".
   "bleibt, ist also praktisch Standard. Es ist der Großbuchstaben der ".
   "gewünschten Möglichkeit einzugeben (oder auch nicht)."), "\n\n";
  print &tssqueeze("Einzelbenutzer oder mehrere hinzufügen?"),
   "\n\n\n";

  print "[Einzelbenutzer/(Mehrere)/Abbrechen] > ";
  chomp($temp = <STDIN>);

  if($temp =~ /^e(?:inzelbenutzer)?$/io) {
    print uc "\nEinzelbenutzer hinzufügen\n\n";
    print &tssqueeze("Wen vergessen? Kein Problem. Es wird nur nach dem".
     " Namen, Geburtsdatum (0.0.0000 für leere Angabe) sowie Klasse und".
     " einer Zielgruppe gefragt. Standardmäßig ist die Zielgruppe das, was".
     " unter \$OPT{\"s_dgrp\"} in der Konfigurationsdatei eingestellt worden".
     " ist."), "\n\n";
    print "s_dgrp ist z.Z: ", $OPT{"s_dgrp"}, "\n\n\n";
    print "Weiter >> (Return drücken)\n";
    <STDIN>;
    print "\n";

    if(!&useradd()) {
      print &tssqueeze("Das Hinzufügen eines Einzelbenutzers ist nicht".
       " fehlerfrei abgelaufen. Bitte Prozedur wiederholen, falls nötig. Der".
       " Assistent beendet sich nun und kehrt zum Hauptmenü zurück."), "\n";
      return 0;
    }
  } elsif($temp =~ /^m(?:ehrere)?$/io) {
    print uc "\nSchritt 1 - Änderungen finden\n\n";
    print &tssqueeze("In diesem Teil wird eine Datei beliebigen Typs".
     " (z.z. nur \"SDF-4/5-field\" unterstützt) eingelesen, und mit die".
     " Änderungen herausgefunden."), "\n\n";
    print &tssqueeze("Es wird gleich nach einem Dateinamen gefragt; es gibt".
     " jetzt (in diesem Augenblick) also die Möglichkeit, eine Diskette zu".
     " mounten, falls nötig. Datei am besten in ein Unterverzeichnis des".
     " ".$OPT{"PROGN"}."-Wurzelverzeichnisses. (Z.B. /usr/local/".
     $OPT{"PROGF"}."/DATUM_VON_HEUTE/)"), "\n\n\n";
    print "Änderungen finden [(Ja)/Abbrechen] > ";
    chomp($temp = <STDIN>);
    if($temp !~ /^j(?:a)?/io) { return 1; }

    print "\n";
    if(!&find_changes()) {
      print &tssqueeze("Die Prozedur, um die nötigen Änderungen zu finden".
       " ist nicht ganz fehlerfrei abgelaufen. Bitte Prozedur wiederholen,".
       " falls nötig. Der Assistent beendet sich nun und kehrt zum".
       " Hauptmenü zurück."), "\n";
      return 0;
    }
      
    print &tssqueeze("\"Änderungen finden\" erfolgreich."), "\n\n";

    print uc("Schritt 2 - Änderungen zuweisen\n\n");
    print &tssqueeze("Es werden nun die Änderungen vollzogen, die im".
     " zuvorgehendem Schritt erarbeitet wurden. Die nötige Zeit, um jene".
     " Benutzer zu löschen variiert je nach eingestellter Kompression bei".
     " der Archivierung der alten Home-Verzeichnisse."), "\n\n\n";
    print "Änderungen zuweisen [(Ja)/Abbrechen] > ";
    chomp($temp = <STDIN>);
    if($temp !~ /^j(?:a)?/io) { return 1; }

    print "\n";
    if(!&apply_changes()) {
      print &tssqueeze("Die Prozedur um die nötigen Änderungen zu vollziehen".
       " ist nicht fehlerfrei abgelaufen. Bitte Prozedur wiederholen, falls".
       " nötig. Der Assistent beendet sich nun und kehrt zum Hauptmenü".
       " zurück."), "\n";
      return 0;
    }

    print &tssqueeze("Änderungen wurden erfolgreich zugewiesen."), "\n\n";

    print uc("Schritt 3 - Passwortlisten drucken\n\n");
    print &tssqueeze("Sollen noch formatierte Passwortlisten erstellt ".
     "werden?"), "\n\n\n";

    print "Passwortlisten erstellen [(Ja)/Nein] > ";
    chomp($temp = <STDIN>);
    if($temp !~ /^j(?:a)?/io) { return 1; }

    print "\n";
    if(!&prlist) {
      print &tssqueeze("Die Erstellung der Passwortlisten ist nicht".
       " fehlerfrei abgelaufen."), "\n";
    }

    print &tssqueeze("Der Assistent ist jetzt fertig, beendet sich und kehrt".
     " zum Hauptmenü zurück."), "\n\n";
  }

  return 1;
}

sub find_changes {
  undef $CURR{"a_ukeep"}; # do not trust garbage collector
  undef $CURR{"a_unew"};
  undef $CURR{"a_udel"};
  $CURR{"a_ukeep"} = [];
  $CURR{"a_unew"} = [];
  $CURR{"a_udel"} = [];
  $CURR{"b_cmpd"} = 0;

  print "\n", &hbar("="), "\n\e[1mÄnderungen finden\e[0m\n", &hbar("="), "\n";
  my $dgid = $OPT{"s_dgrp"};
  if($dgid =~ /\D/iso) { $dgid = &getgrent($dgid, $OPT{"f_group"}); }
  if($dgid eq "") {
    printf "FEHLER: Gruppe \"%s\" hat keine GID oder existiert nicht\n",
     $OPT{"s_dgrp"};
    return 0;
  }

  # ----------------------------------------
  my %dtf = ();
  {
    print "Input-Datei > ";
    chomp(my $inputf = <STDIN>);

    local *IN;
    if(!open(IN, "<".$inputf)) {
      printf "FEHLER: %s konnte nicht geöffnet werden: %s\n", $inputf, $!;
      return 0;
    }

    $CURR{"s_basefile"} = $inputf;
    $CURR{"s_basefile"} =~ s/\.sdf$//go;
    my($buf, $max);
    while(read(IN, $buf, 4096)) { $max += ($buf =~ tr/\x0A//); }
    seek(IN, 0, 0);

    # ----------------------------------------
    my($count, $t_start) = (0, time());
    while(defined(my $l = <IN>)) {
      ++$count;
      if($l =~ /^\(\*.*?\*\)/so || $l =~ /^(?:[\#;]|\/\/)/so || $l eq "") {
       next; }
      if(substr($l, -2, 2) eq "\x0D\x0A") { $l = &to_ansi($l); }
      chomp $l;
      my($nname, $vname, $gebd, $klasse);
      if((split(/;/o, $l))[0] !~ /\D/) {
       (undef, $nname, $vname, $gebd, $klasse) = split(/;/o, $l); }
      else { ($nname, $vname, $gebd, $klasse) = split(/;/o, $l); }
      if($nname eq "" || $vname eq "" || $gebd eq "") {
        printf "FEHLER: Datenfehler in der SDF-Datei, Zeile %d\n", $count;
        print "[Assertion: nname eq \"\" || vname eq \"\" || gebd eq \"\"\n";
        close IN;
        print "\n";
        return 0;
      }

      my $lname = &name2user($nname, $vname);
      $dtf{$vname." ".$nname.",".&enday($gebd)} = [$lname, $klasse];
      print &pstat($count, $max, 5, $t_start, time());
    }

    close IN;
  }

  # ----------------------------------------
  my %ph = ();

  {
    local *PASSWD;
    if(!open(PASSWD, "<".$OPT{"f_passwd"})) {
      printf "FEHLER: %s konnte nicht geöffnet werden: %s\n",
       $OPT{"f_passwd"}, $!;
      return 0;
    }

    my($buf, $max);
    while(read(PASSWD, $buf, 4096)) { $max += ($buf =~ tr/\x0A//); }
    seek(PASSWD, 0, 0);

    my($count, $users_g, $users_k, $t_start) = (0, 0, 0, time());
    printf "Lese %s:\n", $OPT{"f_passwd"};
    while(defined(my $l = <PASSWD>)) {
      ++$count;
      chomp $l;
      if(substr($l, 0, 1) eq "#" || $l eq "") { next; }
      my($lname, undef, undef, $gid, $gcos) = split(/:/o, $l);
      my($gcname, $gcdate, $gcrest) = split(/,/o, $gcos, 3);
      $ph{$lname} = 1;

      if($gid == $dgid) {
        ++$users_g;
        if(defined $dtf{$gcname.",".$gcdate}) {
          ++$users_k;
          delete $dtf{$gcname.",".$gcdate};
        } else { push(@{$CURR{"a_udel"}}, $lname); }
      }

      print &pstat($count, $max, 5, $t_start, time());
    }

    close PASSWD;
    printf "%d Gruppenhauptmitglied%s gefunden\n", $users_g,
     ($users_g == 1) ? "" : "er";

    printf "  davon %d behalten\n", $users_k;
    printf "  davon %d zu entfernen\n", scalar @{$CURR{"a_udel"}};
    printf "%d neue hinzuzufügen\n", scalar keys %dtf;
  }

  # ----------------------------------------
  {
    open(LOG, ">debugadd.log");
    foreach my $gcnd (sort keys %dtf) {
      my($lname, $klasse) = @{$dtf{$gcnd}};
      my($gcname, $gcdate) = split(/,/o, $gcnd);
      my($i, $llname) = ("", $lname);

      while($ph{$llname} ne "") {
        ++$i;
        $llname = substr($lname, 0, 8 - length($i)).$i;
      }

      $ph{$llname} = 1;
      push(@{$CURR{"a_unew"}}, [$llname, $gcname, $gcdate, $klasse]);
      printf LOG "llname=%s gcname=%s gcdate=%s klasse=%s\n",
       $llname, $gcname, $gcdate, $klasse;
    }

    printf "(Bestätigt: %d neue Benutzer)\n", scalar @{$CURR{"a_unew"}};
    close LOG;
  }

  $CURR{"b_cmpd"} = 1;
  return 1;
}

sub apply_changes {
  print "\n\n\n", &hbar("="), "\n\e[1mÄnderungen zuweisen\e[0m\n",
   &hbar("="), "\n";

  # ----------------------------------------
  if(!$CURR{"b_cmpd"}) {
    print "FEHLER: Keine verglichenen Listen vorhanden\n";
    return 0;
  }

  $CURR{"b_cmpd"} = 0;
  &INIT_genstuff();
  print "\nErstelle Backups\n";
  system "cp", "-ai", $OPT{"f_passwd"}, $CURR{"s_basefile"}.".opasswd";
  system "cp", "-ai", $OPT{"f_shadow"}, $CURR{"s_basefile"}.".oshadow";
  $CURR{"s_dqrfile"} = $CURR{"s_basefile"}.".dqr";
  my $logfile = $CURR{"s_basefile"}.".log";

  for(my $c = 2; $c >= 0; --$c) {
    printf "\rWeiter in %d Sekunde%s\e[K", $c, (($c != 1) ? "n" : "");
    sleep 1;
  }
  printf "\n";

  # ----------------------------------------
  if(@{$CURR{"a_unew"}} > 0) {
    local *DQR;
    if(!open(DQR, ">".$CURR{"s_dqrfile"})) {
      printf "FEHLER: Konnte %s nicht öffnen: %s\n", $CURR{"s_dqrfile"}, $!;
      return 0;
    }

    printf DQR "%s (%s) - DQR\n", @OPT{"PROGN","PROGV"};
    print "Hinzufügen der neuen Benutzer\n";

    my($count, $max, $t_start) = (0, scalar(@{$CURR{"a_unew"}}), time());
    foreach my $l (@{$CURR{"a_unew"}}) {
      my($lname, $gcname, $gcdate, $klasse) = @$l;
      my($encpass, $pass) = &genpass();
      if($OPT{"p_preadd"} ne "") {
        system sprintf $OPT{"pa_preadd"}, $OPT{"p_preadd"}, $lname, $encpass,
         $OPT{"s_dgrp"}, join(",", $gcname, $gcdate), "/bin/bash",
         $OPT{"f_skeldir"};
      }

      system sprintf $OPT{"pa_useradd"}, $OPT{"p_useradd"}, $lname, $encpass,
       $OPT{"s_dgrp"}, join(",", $gcname, $gcdate), "/bin/bash",
       $OPT{"f_skeldir"};
      printf DQR "%s:%s:%s:%s\n", $klasse, $gcname, $lname, $pass;

      if($OPT{"p_postadd"} ne "") {
       system sprintf $OPT{"pa_postadd"}, $OPT{"p_postadd"}, $lname; }

      print &pstat(++$count, $max, 5, $t_start, time());
    }

    print &pstat($count, $max, 3, $t_start, time());
    close DQR;
  }

  # ----------------------------------------
  if(@{$CURR{"a_udel"}} > 0) {
    {
      print "Entfernen der Benutzer (1 / 2)\n";

      my($count, $max, $t_start) = (0, scalar(@{$CURR{"a_udel"}}), time());
      foreach my $l (@{$CURR{"a_udel"}}) {
        system "passwd -l ".$l." >/dev/null 2>&1";
        if(-e "/var/spool/cron/tabs/".$l) {
          system "cp /var/spool/cron/tabs/".$l." ~".$l."/._crontab";
          system "crontab -eu $l";
        }
        if(-e "/var/spool/mail/".$l) {
         system "mv /var/spool/mail/".$l." ~".$l."/._mailbox"; }
        print &pstat(++$count, $max, 5, $t_start, time());
      }

      print &pstat($count, $max, 5, $t_start, time());
      print "Sende Signale SIGTERM und SIGKILL\n";
      system "kill -15 `ps --no-headers -U ".join(",", @{$CURR{"a_udel"}}).
       " -u ".join(",", @{$CURR{"a_udel"}})." -o pid` 2>/dev/null";
      sleep 5;
      system "kill -9 `ps --no-headers -U ".join(",", @{$CURR{"a_udel"}}).
       " -u ".join(",", @{$CURR{"a_udel"}})." -o pid` 2>/dev/null";
    }

    # ----------------------------------------
    {
      chomp(my $date = `date +\%Y-\%m-\%d.\%H-\%M`);
      mkdir sprintf "%s/%s", $OPT{"f_trhome"}, $date;
      print "Entfernen der Benutzer (2 / 2)\n";

      my($count, $max, $t_start) = (0, scalar(@{$CURR{"a_udel"}}), time());
      foreach my $l (@{$CURR{"a_udel"}}) {
        if($OPT{"b_zpack"} == 1) {
          system sprintf "tar -cf \"%s/%s/%s.tar\" ~%s 2>/dev/null",
           $OPT{"f_trhome"}, $date, $l, $l;
        } elsif($OPT{"b_zpack"} == 2) {
          system sprintf "tar -cjf \"%s/%s/%s.tbz2\" ~%s 2>/dev/null",
           $OPT{"f_trhome"}, $date, $l, $l;
        }

        if($OPT{"p_predel"} ne "") {
         system sprintf $OPT{"pa_predel"}, $OPT{"p_predel"}, $l; }

        system sprintf $OPT{"pa_userdel"}, $OPT{"p_userdel"}, $l;

        if($OPT{"p_postdel"} ne "") {
         system sprintf $OPT{"pa_postdel"}, $OPT{"p_postdel"}, $l; }

        print &pstat(++$count, $max, 5, $t_start, time());
      }
    }
  }

  return 1;
}

sub prlist {
  print "\n\n\n", &hbar("="), "\n\e[1mPasswortliste drucken\e[0m\n",
   &hbar("="), "\n";

  # ----------------------------------------
  local *DQR;

  print "DQR-Datei [".$CURR{"s_dqrfile"}."] > ";
  chomp(my $inputf = <STDIN>);
  if($inputf ne "") { $CURR{"s_dqrfile"} = $inputf; }

  if(!open(DQR, "<".$CURR{"s_dqrfile"})) {
    printf "FEHLER: Konnte %s nicht öffnen: %s\n", $CURR{"s_dqrfile"}, $!;
    return 0;
  }

  if(<DQR> !~ /^$OPT{"PROGN"} \($OPT{"PROGV"}\) - DQR\x0A?$/so) {
    printf "FEHLER: %s: das Format wird nicht unterstützt\n",
     $CURR{"s_dqrfile"};
    return 0;
  }

  # ----------------------------------------
  my($pm, $temp, $txtfile) =
   (0, "", &modext($CURR{"s_dqrfile"}, ".dqr", ".txt"));
  local *OUT;

  printf "Schreiben in [%s] > ", $txtfile;
  chomp($temp = <STDIN>);
  if($temp ne "") { $txtfile = $temp; }

  if(!open(OUT, ">".$txtfile)) {
    printf "FEHLER: Konnte %s nicht öffnen: %s\n", $txtfile, $!;
    return 0;
  }

  chmod 0600, $txtfile;
  printf "Verfahren (0=StandardSuchen, 1=SortiertNachKlassen) [0] > ";
  chomp($temp = <STDIN>);
  if($temp ne "") { $pm = $temp; }
  if($pm < 0 || $pm > 1) {
    print "Ungültige Angabe. Tendiere zu 0.\n";
    $pm = 0;
  }

  if($pm == 0) {
    print "Suchmuster Klasse [".$CURR{"r_klasse"}."] > ";
    chomp($temp = <STDIN>);
    if($temp ne "") { $CURR{"r_klasse"} = $temp; }

    print "Suchmuster Loginname [".$CURR{"r_lname"}."] > ";
    chomp($temp = <STDIN>);
    if($temp ne "") { $CURR{"r_lname"} = $temp; }

    print "Suchmuster Realname [".$CURR{"r_rname"}."] > ";
    chomp($temp = <STDIN>);
    if($temp ne "") { $CURR{"r_rname"} = $temp; }

    my $e;
    printf OUT "\n%-6s   %-26s   %-12s   %-8s\n%s\n",
     "Klasse", "Name", "Benutzername", "Passwort", "-" x 61;

    while(defined(my $l = <DQR>)) {
      chomp $l;
      if($l =~ /^$CURR{"r_klasse"}:$CURR{"r_rname"}:$CURR{"r_lname"}:.*/is) {
        ++$e;
        printf OUT "%-6s   %-30s   %-8s   %-8s\n", split(/:/o, $l);
      }
    }
  } elsif($pm == 1) {
    my $prev;

    foreach my $e (sort _prlist_sort <DQR>) {
      chomp $e;
      my @e = split(/:/o, $e);
      if($e[0] ne $prev) {
        printf OUT "\n%-6s   %-26s   %-12s   %-8s\n%s\n",
         "Klasse", "Name", "Benutzername", "Passwort", "-" x 61;
      }

      printf OUT "%-6s   %-30s   %-8s   %-8s\n", @e;
      $prev = $e[0];
    }
  }

  close DQR;
  close OUT;
  return 1;
}

sub useradd {
  undef $CURR{"a_ukeep"}; # do not trust garbage collector
  undef $CURR{"a_unew"};
  undef $CURR{"a_udel"};
  $CURR{"a_ukeep"} = [];
  $CURR{"a_unew"} = [];
  $CURR{"a_udel"} = [];
  $CURR{"s_basefile"} = $CURR{"s_dqrfile"} = "";
  $CURR{"b_cmpd"} = 0;
  print "\n\n\n", &hbar("="), "\n", "\e[1mEinzelbenutzer hinzufügen\e[0m\n",
   &hbar("="), "\n";

  # ----------------------------------------
  my($dgid, $gebd, $nname, $vname) = ($OPT{"s_dgrp"});

  while($nname eq "") {
    print "Nachname > ";
    chomp($nname = <STDIN>);
    if($nname eq "") { print "Kein Vornamen angegeben!\n"; }
  }

  while($gebd eq "") {
    print "Geburtsdatum > ";
    chomp($gebd = <STDIN>);
    if($gebd !~ /^\d\d?\.\d\d?\.\d{4}/o) {
     print "Geburtsdatum entspricht nicht dem Schema T.M.YYYY!\n"; }
  }

  while($vname eq "") {
    print "Vorname > ";
    chomp($vname = <STDIN>);
    if($vname eq "") { print "Kein Vorname angegeben!\n"; }
  }

  printf "Klasse > ";
  chomp(my $klasse = <STDIN>);

  printf "Zielgruppe [%s] > ", $dgid;
  chomp(my $temp = <STDIN>);
  if($temp ne "") { $dgid = $temp; }

  # ----------------------------------------
  $lname = &name2user($nname, $vname);
  $dtfline = sprintf "%s:%s %s:%s:%s", $lname, $vname, $nname, $gebd, $klasse;

  if($dgid =~ /\D/iso) { $dgid = &getgrent($dgid); }
  if($dgid eq "") {
    printf "FEHLER: \"%s\" hat keine GID oder existiert nicht\n", $dgid;
    return 0;
  }

  # ----------------------------------------
  my %ph = ();

  {
    local *PASSWD;
    if(!open(PASSWD, "<".$OPT{"f_passwd"})) {
      printf "FEHLER: Konnte %s nicht öffnen: %s\n", $OPT{"f_passwd"}, $!;
      return 0;
    }

    my($buf, $max);
    while(read(PASSWD, $buf, 4096)) { $max += ($buf =~ tr/\x0A//); }
    seek(PASSWD, 0, 0);

    my($count, $users_g, $users_k, $t_start) = (0, 0, 0, time());
    printf "Lese %s:\n", $OPT{"f_passwd"};
    while(defined(my $l = <PASSWD>)) {
      ++$count;
      chomp $l;
      if(substr($l, 0, 1) eq "#" || $l eq "") { next; }
      my($lname, undef, undef, $gid, $gcos) = split(/:/o, $l);
      my($gcname, $gcdate, $gcrest) = split(/,/o, $gcos, 3);
      $ph{$lname} = 1;
      if($gid == $dgid) { ++$users_g; }
      print &pstat($count, $max, 5, $t_start, time());
    }

    close PASSWD;
    printf "%d Gruppenhauptmitglied%s gefunden\n", $users_g,
     ($users_g == 1) ? "" : "er";
  }

  # ----------------------------------------
  my $ud;

  {
    my($lname, $gcname, $gcdate, $klasse) = split(/:/o, $dtfline);
    my($i, $llname) = ("", $lname);

    while($ph{$llname} ne "") {
      ++$i;
      $llname = substr($lname, 0, 8 - length($i)).$i;
    }

    $ph{$llname} = 1;
    $ud = [$llname, $gcname, $gcdate, $klasse];
  }

  push(@$ud, &genpass());
  if($OPT{"p_preadd"} ne "") {
    system sprintf $OPT{"pa_preadd"}, $OPT{"p_preadd"}, $ud->[0], $ud->[5],
     $OPT{"s_dgrp"}, join(",", $ud->[1], $ud->[2]), "/bin/bash",
     $OPT{"f_skeldir"};
    print "Preadd-Befehl ausgeführt.\n";
  }

  system sprintf $OPT{"pa_useradd"}, $OPT{"p_useradd"}, $ud->[0], $ud->[5],
   $OPT{"s_dgrp"}, join(",", $ud->[1], $ud->[2]), "/bin/bash",
   $OPT{"f_skeldir"};

  if($OPT{"p_postadd"} ne "") {
    system sprintf $OPT{"pa_postadd"}, $OPT{"p_postadd"}, $ud->[0];
    print "Postadd-Befehl ausgeführt.\n";
  }

  print "User angelegt. Passwort anzeigen? [Ja] ";
  chomp(my $sp = <STDIN>);
  if($sp eq "" || $sp =~ /^ja?$/io) {
   print "Passwort ist: \e[1;30m\n\t".$ud->[5]."\n\e[0m"; }

  {
    local *DQR;
    chomp(my $date = `date "+\%Y\%m\%d\%H\%M\%S"`);
    print "singleadd-".$date.".dqr wird generiert\n";
    open(DQR, ">singleadd-".$date.".dqr");
    printf DQR "%s (%s) - DQR\n", @OPT{"PROGN","PROGV"};
    printf DQR "%s:%s %s:%s:%s\n", "-", @$ud[3,1,0,5];
    close DQR;
  }

  return 1;
}

sub userdetails {
  print "\n\n\n", &hbar("="), "\n\e[1mBenutzerdetails\e[0m\n",
   &hbar("="), "\n";

  # ----------------------------------------
  {
    my $temp;

    print "Suchmuster Loginname [".$CURR{"r_lname"}."] > ";
    chomp($temp = <STDIN>);
    if($temp ne "") { $CURR{"r_lname"} = $temp; }

    print "Suchmuster UID [".$CURR{"r_uid"}."] > ";
    chomp($temp = <STDIN>);
    if($temp ne "") { $CURR{"r_uid"} = $temp; }

    print "Suchmuster GID [".$CURR{"r_gid"}."] > ";
    chomp($temp = <STDIN>);
    if($temp ne "") { $CURR{"r_gid"} = $temp; }

    print "Suchmuster Realname [".$CURR{"r_rname"}."] > ";
    chomp($temp = <STDIN>);
    if($temp ne "") { $CURR{"r_rname"} = $temp; }

    print "Suchmuster Homeverzeichnis [".$CURR{"r_homedir"}."] > ";
    chomp($temp = <STDIN>);
    if($temp ne "") { $CURR{"r_homedir"} = $temp; }

    print "Suchmuster Loginshell [".$CURR{"r_shell"}."] > ";
    chomp($temp = <STDIN>);
    if($temp ne "") { $CURR{"r_shell"} = $temp; }
  }

  # ----------------------------------------
  my(@ph, %ph) = ();

  {
    local *PASSWD;
    if(!open(PASSWD, "<".$OPT{"f_passwd"})) {
      printf "FEHLER: Konnte %s nicht öffnen: %s\n", $OPT{"f_passwd"}, $!;
      return 0;
    }

    print &hbar("-"), "\n";
    my($count, $list) = (0, []);
    while(defined(my $l = <PASSWD>)) {
      chomp $l;
      if($l =~ /^$CURR{"r_lname"}:.*?:$CURR{"r_uid"}:$CURR{"r_gid"}:$CURR{"r_rname"}(,.*?)?:$CURR{"r_homedir"}:$CURR{"r_shell"}$/is) {
        my($lname, undef, $uid, $gid, $gcos, $home, $shell) = split(/:/o, $l);
        my($rname, $gebd, $rgcos) = split(/,/o, $gcos, 2);
        $ph[$count] = $lname;
        $ph{$lname} = $l;
        printf "%4d  %-21s  %-35s\n", ++$count,
         $lname."(".$uid."/".$gid.")", $rname;
      }
    }

    close PASSWD;
  }

  print "   0 Zurück zum Hauptmenü\n";
  print "WAHL > ";
  chomp(my $ln = <STDIN>);

  if($ln eq "" || $ln < 1 || $ln > scalar @$ph) { return 1; }
  if($ln !~ /\D/iso) { $ln = $ph->[--$ln]; }

  # ----------------------------------------
  my($lname, undef, $uid, $gid, $gcos, $home, $shell) =
   split(/:/o, $ph{$ln});
  my($rname, $gebd, $rgcos) = split(/,/o, $gcos, 3);
  my $accstat = "UNAVAILABLE";

  @_ = &getpwent($lname);
  if($@ ne "") { print $@."\n"; return 0; }
  if(substr($_[5], 0, 1) eq "!") { $accstat = "CLOSED"; }
  else { $accstat = "OPEN"; }

  # ----------------------------------------
  my($ed_h, $ed_s, $ed_p) = (0, 0, 0);

  {
    while() {
      print &hbar("-"), "\n";
      printf "      Loginname / UID : [%s]%s\n", $uid, $lname;
      printf "   1. Gruppe / GID    : [%s]%s\n", $gid, getgrgid($gid);
      printf "   2. Realname        : %s\n", $rname;
      printf "   3. Mehr GCOS       : %s\n", $rgcos;
      printf "   4. Account-Status  : %s\n", $accstat;
      printf "   5. Homeverzeichnis : %s\n", $home;
      printf "   6. Login-Shell     : %s\n", $shell;
      printf "   0. %s\n", ($ed_p > 0 || $ed_s > 0 || $ed_h > 0) ?
       "Speichern" : "Zurück";
      print "WAHL> ";
      chomp(my $INKEY = <STDIN>);

      # ----------------------------------------
      if($INKEY eq "1") {
        print "Gruppe / GID [".$gid."] > ";
        chomp(my $temp = <STDIN>);
        if($temp ne "") {
          if($temp =~ /\D/iso) { $gid = &getgrent($temp); }
          else { $gid = $temp; }
          $ed_p = 1;
        }
      } elsif($INKEY eq "2") {
        print "Realname [".$rname."] > ";
        chomp(my $temp = <STDIN>);
        if($temp ne "") { ($rname, $ed_p) = ($temp, 1); }
      } elsif($INKEY eq "3") {
        print "Mehr GCOS [".$rgcos."] > ";
        chomp($temp = <STDIN>);
        if($temp ne "") { ($rgcos, $ed_p) = ($temp, 1); }
      } elsif($INKEY eq "4") {
        print "Neuer Status (OPEN, CLOSED, DELETE) [".$accstat."] > ";
        chomp($temp = <STDIN>);
        if($temp ne "") {
          if($temp =~ /^O(?:PEN)?$/io) {
           ($ed_s, $accstat) = (1, "OPEN"); }
          elsif($temp =~ /^C(?:LOSED?)?$/io) {
           ($ed_s, $accstat) = (1, "CLOSED"); }
          elsif($temp =~ /^DELETE$/io) {
           ($ed_s, $accstat) = (1, "TO BE DELETED"); }
        }
      } elsif($INKEY eq "5") {
        print "Homeverzeichnis [".$home."] > ";
        chomp($temp = <STDIN>);
        if($temp ne "") { ($home, $ed_p, $ed_h) = ($temp, 1, 1); }
      } elsif($INKEY eq "6") {
        print "Login-Shell [".$shell."] > ";
        chomp($temp = <STDIN>);
        if($temp ne "") { ($shell, $ed_p) = ($temp, 1); }
      } elsif($INKEY eq "0" || lc($INKEY) eq "q") { last; }
    }
  }

  # ----------------------------------------
  if($accstat eq "TO BE DELETED") {
    system "passwd -l ".$lname." >/dev/null 2>&1";
    if(-e "/var/spool/cron/tabs/".$lname) {
     system "mv /var/spool/cron/tabs/".$lname." ~".$lname."/._crontab"; }
    if(-e "/var/spool/mail/".$lname) {
     system "mv /var/spool/mail/".$lname." ~".$lname."/._mailbox"; }

    print "Sende Signale SIGTERM und SIGKILL\n";
    system "kill -15 `ps --no-headers -U ".$lname." -u ".$lname.
     " -o pid` 2>/dev/null";
    sleep 5;
    system "kill -9 `ps --no-headers -U ".$lname." -u ".$lname.
     " -o pid` 2>/dev/null";

    chomp(my $date = `date +\%Y-\%m-\%d.\%H-\%M`);
    mkdir sprintf "%s/%s", $OPT{"f_trhome"}, $date;

    if($OPT{"b_zpack"} == 1) {
      system sprintf "tar -cf \"%s/%s/%s.tar\" ~%s 2>/dev/null",
       $OPT{"f_trhome"}, $date, $lname, $lname;
    } elsif($OPT{"b_zpack"} == 2) {
      system sprintf "tar -cjf \"%s/%s/%s.tbz2\" ~%s 2>/dev/null",
       $OPT{"f_trhome"}, $date, $lname, $lname;
    }

    if($OPT{"p_predel"} ne "") {
     system sprintf $OPT{"pa_predel"}, $OPT{"p_predel"}, $lname; }

    system sprintf $OPT{"pa_userdel"}, $OPT{"p_userdel"}, $lname;

    if($OPT{"p_postdel"} ne "") {
     system sprintf $OPT{"pa_postdel"}, $OPT{"p_postdel"}, $lname; }
    ($ed_p, $ed_s, $ed_h) = (0, 0, 0);
  }

  # ----------------------------------------
  if($ed_h > 0) {
    system "passwd -l ".$lname." >/dev/null 2>&1";
    print "Sende Signale SIGTERM und SIGKILL\n";
    system "kill -15 `ps --no-headers -U ".$lname." -u ".$lname.
     " -o pid` 2>/dev/null";
    sleep 5;
    system "kill -9 `ps --no-headers -U ".$lname." -u ".$lname.
     " -o pid` 2>/dev/null";

    if(!system "mv ~".$lname." \"".$home."\"") {
     system "passwd -u ".$lname." >/dev/null 2>&1"; }
    else { print "Fehler beim Verschieben. Account bleibt verschlossen.\n"; }
  }

  # ----------------------------------------
  if($ed_p > 0) {
    local *PASSWD;

    if(!open(PASSWD, "<".$OPT{"f_passwd"})) {
      printf "FEHLER: Konnte %s nicht öffnen: %s\n", $OPT{"f_passwd"}, $!;
      return 0;
    }

    my $pwa = [<PASSWD>];
    close PASSWD;

    if(!open(PASSWD, ">".$OPT{"f_passwd"})) {
      printf "FEHLER: Konnte %s nicht öffnen: %s\n", $OPT{"f_passwd"}, $!;
      return 0;
    }

    for(my $l = 0; $l < scalar @$pwa; ++$l) {
      chomp $pwa->[$l];
      my $fgcos = join(",", $rname, $gebd, $rgcos);
      $fgcos =~ s/,+$//go;
      $pwa->[$l] =~ s/^$lname:.*/join(":", $lname, "x", $uid, $gid, $fgcos,
       $home, $shell)/egis;
      print PASSWD $pwa->[$l]."\n";
    }

    close PASSWD;
    $ed_p = 0;
  }

  # ----------------------------------------
  if($ed_s > 0) {
    local *SHADOW;

    if(!open(SHADOW, "<".$OPT{"f_shadow"})) {
      printf "FEHLER: Konnte %s nicht öffnen: %s\n", $OPT{"f_shadow"}, $!;
      return 0;
    }

    my $sha = [<SHADOW>];
    close SHADOW;

    if(!open(SHADOW, ">".$OPT{"f_shadow"})) {
      printf "FEHLER: Konnte %s nicht öffnen: %s\n", $OPT{"f_shadow"}, $!;
      return 0;
    }

    for(my $l = 0; $l < scalar @$sha; ++$l) {
      chomp $sha->[$l];
      $sha->[$l] =~ s/^($lname:)!?(.*)/$1.(($accstat eq "CLOSED") ?
       "!" : "").$2/egis;
      print SHADOW $sha->[$l]."\n";
    }

    close SHADOW;
    $ed_s = 0;
  }

  return 1;
}

#------------------------------------------------------------------------------
sub INIT_genstuff {
  print "Generating stuff [";
  foreach my $l (@OPT{"f_skeldir","f_trhome"}) {
    print " ".$l;
    if((-e $l && !-d $l) || !-e $l) { print "!"; }
    if(-e $l && !-d $l) { print "U"; unlink $l || print ": Error: ".$!; }
    if(!-e $l) { print "C"; mkdir $l || print ": Error: ".$!; }
  }

  print " ]\n";
  return 1;
}

sub _prlist_sort {
  my @c = split(/:/o, $a);
  my @d = split(/:/o, $b);
  my $r = $c[0] cmp $d[0]; if($r != 0) { return $r; }
  $r = $c[1] cmp $d[1]; if($r != 0) { return $r; }
  return $c[2] cmp $d[2];
}

sub genpass {
  my $pass;
  for(my $count = 0; $count < $OPT{"s_passlen"}; ++$count) {
   $pass .= !int(rand 5) ? int(rand 10) : chr(int(rand 26) + 97); }
  my $salt = join("", (".", "/", 0..9, "A".."Z", "a".."z")[rand(64), rand 64]);
  return(crypt($pass, $salt), $pass);
}

sub getgrent {
  my($g, $fg) = @_;
  local *FG;
  $@ = "";

  if(!open(FG, "<".($fg ||= "/etc/group"))) {
    $@ = sprintf "Could not open %s: %s", $fg, $!;
    return undef;
  }

  if(($g = lc $g) eq "") { $g = (split(/ /o, $)))[0]; }
  if(!wantarray) {
    while(defined(my $l = <FG>)) {
      my @lg = split(/:/o, $l);
      if($g =~ /\D/iso) { if($g eq lc $lg[0]) { close FG; return $lg[2]; } }
      elsif($lg[2] == $g) { close FG; return lc $lg[0]; }
    }
  } else {
    while(defined(my $l = <FG>)) {
      if($g !~ /\D/iso) {
        my @lg = split(/:/o, $l);
        if($lg[2] == $g) { $g = lc $lg[0]; }
      }

      my @lg = split(/:/o, $l);
      if($g eq lc $lg[0]) {
        close FG;
        return @lg[0,2,3];
      }
    }
  }

  close FG;
  return undef;
}

sub getpwent {
  my($u, $fp, $fs) = @_;
  local(*FP, *FS);
  if(!open(FP, "<".($fp ||= "/etc/passwd"))) {
    $@ = sprintf "Could not open %s: %s", $fp, $!;
    return undef;
  }

  if(!open(FS, "<".($fs ||= "/etc/shadow"))) {
    $@ = sprintf "Could not open %s: %s", $fs, $!;
    close FP;
    return undef;
  }

  if(($u = lc $u) eq "") { $u = $>; }
  if(!wantarray) {
    while(defined(my $l = <FP>)) {
      my @lp = split(/:/o, $l);
      if($u =~ /\D/iso) {
       if($u eq lc $lp[0]) { close FP; close FS; return $lp[2]; } }
      elsif($lp[2] == $u) { close FP; close FS; return lc $lp[0]; }
    }
  } else {
    while(defined(my $l = <FP>)) {
      if($u !~ /\D/iso) {
        my @lp = split(/:/o, $l);
        if($lp[2] == $u) { $u = lc $lp[0]; }
      }

      my @lp = split(/:/o, $l);
      if($u eq lc $lp[0]) {
        close FP;

        while(defined(my $l = <FS>)) {
          my @ls = split(/:/o, $l);
          if($u eq lc $ls[0]) {
            close FS;
            return @lp[0,2..5], @ls[1..7];
          }
        }

        close FS;
        return @lp[0,2..5];
      }
    }
  }

  close FP;
  close FS;
  return undef;
}

sub hbar { return $_[0] x (($OPT{"s_termwx"} / length($_[0])) - 1); }

sub modext {
  my($inputf, $ext1, $ext2) = (@_);
  if(substr($inputf, -length($ext1), length($ext1)) eq $ext1) {
   $inputf = substr($inputf, 0, length($inputf) - length($ext1)); }
  $inputf .= $ext2;
  return $inputf;
}

sub name2user {
  my($in, $vname) = @_;
  $in =~ s/(?:.*\s+)?(.*)/$1/s;
  $in =~ s/[- \'\"\`]//go;
  $in = substr($vname, 0, 1).$in;
  $in =~ s/[Ää]/ae/gio;
  $in =~ s/[Öö]/oe/gio;
  $in =~ s/[Üü]/ue/gio;
  $in =~ s/ß/ss/gio;
  $in =~ s/[Ææ]/ae/gio;
  $in =~ s/[ÀÁÂÃÅàáâãåª]/a/gio;
  $in =~ s/[¢©Çç]/c/gio;
  $in =~ s/[¤ÈÉÊËèéêë]/e/gio;
  $in =~ s/[ÌÍÎÏìíîï]/i/gio;
  $in =~ s/[ÒÓÔÕÖòóôõøº°Ø]/o/gio;
  $in =~ s/[ÙÚÛÜùúû]/u/gio;
  $in =~ tr/£µÑñ®×¥Ýýÿ/lmnnrxyyyy/;
  $in =~ s/[^a-z]//giso;
  $in = &strlower_iso($in);
  $in = substr($in, 0, 7);
  return $in;
}

sub pstat {
  my($count, $max, $opt, $t_start, $t_end) = @_;
  my $rv = sprintf "%s%.0f von %.0f (%.2f%%)",
   ($opt & 1) ? "\r" : "", $count, $max, $count * 100 / $max;

  if($t_start ne "") {
    $rv .= sprintf " [elap: %.0fs, est: %.0fs", $t_end -
     $t_start, ($t_end - $t_start) * $max / $count;
  }

  if($t_end - $t_start > 0) {
   $rv .= sprintf ", ajps: %.2f", $count / ($t_end - $t_start); }

  if($t_start ne "") { $rv .= "]\e[K"; }
  if($opt & 2 || ($count == $max && $opt & 4)) { $rv .= "\n"; }
  return $rv;
}

sub strlower_iso {
  my $IN = shift @_;
  $IN =~ tr/A-Z\xC0-\xD6\xD8-\xDE/a-z\xE0-\xF6\xF8-\xFE/;
  return $IN;
}

sub tssqueeze {
  my $t = shift @_;
  my $x = $OPT{"s_termwx"};
  my @rv;
  while($t =~ s/(.{1,$x})(\s+|\z)/push(@rv, $1), ""/egs) { }
  return join("\n", @rv);
}

sub die {
  printf STDERR @_;
  printf STDERR "\n";
  exit 1;
}

#==[ End of file ]=============================================================
